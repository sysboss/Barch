#!/usr/bin/perl
#
# Barch v6.1
# Copyright (c) 2015 Alexey Baikov <sysboss[@]mail.ru>
#
# LVM backup solution
# An open source LVM backup utility for linux based systems.
# Barch conducts automatic and predefined volume structure recognition.
# Supports incremental backups. Based on duplicity.
#

use strict;
use warnings;

use JSON;
use Switch;
use AnyEvent;
use XML::Simple;
use Sys::Syslog;
use Time::Piece;
use Net::OpenSSH;
use Getopt::Long;
use Config::Tiny;
use LWP::UserAgent;
use Twiggy::Server;
use AnyEvent::Util;
use File::Lockfile;
use AnyEvent::HTTP;
use File::Find::Rule;
use POSIX       'setsid';
use List::Util  'first';
use Digest::MD5 'md5_hex';
use Time::HiRes 'gettimeofday';

my $version = "6.1";
my $welcome = "Barch v$version - LVM Backup Solution";

# required tools
chomp( my $lvm       = `which lvm`       ); if( !$lvm       ){ die "[ERR] No LVM found";       }
chomp( my $lvs       = `which lvs`       ); if( !$lvs       ){ die "[ERR] No lvs found";       }
chomp( my $vgs       = `which vgs`       ); if( !$vgs       ){ die "[ERR] No vgs found";       }
chomp( my $rm        = `which rm`        ); if( !$rm        ){ die "[ERR] No rm found";        }
chomp( my $ssh       = `which ssh`       ); if( !$ssh       ){ die "[ERR] No ssh found";       }
chomp( my $mount     = `which mount`     ); if( !$mount     ){ die "[ERR] No mount found";     }
chomp( my $umount    = `which umount`    ); if( !$umount    ){ die "[ERR] No umount found";    }
chomp( my $file      = `which file`      ); if( !$file      ){ die "[ERR] No file found";      }
chomp( my $kpartx    = `which kpartx`    ); if( !$kpartx    ){ die "[ERR] No kpartx found";    }
chomp( my $duplicity = `which duplicity` ); if( !$duplicity ){ die "[ERR] No duplicity found"; }
chomp( my $nice      = `which nice`      ); if( !$nice      ){ die "[ERR] No nice found";      }
chomp( my $ionice    = `which ionice`    ); if( !$ionice    ){ die "[ERR] No ionice found";    }
chomp( my $gpg       = `which gpg`       ); if( !$gpg       ){ die "[ERR] No gpg found";       }
chomp( my $parted    = `which parted`    ); if( !$parted    ){ die "[ERR] No parted found";    }
chomp( my $touch     = `which touch`     ); if( !$touch     ){ die "[ERR] No touch found";     }
chomp( my $mkdir     = `which mkdir`     ); if( !$mkdir     ){ die "[ERR] No mkdir found";     }

# signals handler
$SIG{TERM} = 'sigHandler';
$SIG{INT}  = 'sigHandler';

# options
my $verbose ;
my $cleanup ;
my $debug   ;
my $chconfig;
my $singleLV;
my $showhelp;
my $showV   ;
my $dry_run ;
my $graceful;
my $daemon  ;

sub usage {
    print << "_END_USAGE";
$welcome
Copyright (c) 2015 Alexey Baikov <sysboss[\@]mail.ru>

usage: $0 [options] FROM

Options:
  -c|--cleanup             Recovery mode
  -o|--only                Single logical volume to backup
  -h|--help                Help (this info)
  -d|--daemon              Run as a daemon
  --graceful               Graceful stop
  --version                Display version
  --syntax                 Verify config file syntax

Debug Options:
  -v|--verbose             Log to stdout
  --debug                  Debug mode (very verbose)
  --dry-run                Discover only mode

_END_USAGE

    exit 0;
}

GetOptions(
    'v|verbose'  => \$verbose,
    'version'    => \$showV,
    'h|help'     => \$showhelp,
    'c|cleanup'  => \$cleanup,
    'debug'      => \$debug,
    'o|only=s'   => \$singleLV,
    'syntax'     => \$chconfig,
    'dry-run'    => \$dry_run,
    'graceful'   => \$graceful,
    'd|daemon'   => \$daemon,
) || usage( "bad option" );

####################
# Configuration    #
####################
my $pwd  = '/etc/barch';
my $pref = '_bsnap';
my $conf = Config::Tiny->read("$pwd/barch.conf");

sub check_config {
    die "$pwd/barch.conf file not found"
        if not -e "$pwd/barch.conf";

    # required sections
    my @sections = ('default', 'global', 'snapshots', 'duplicity', 'advanced');
    my $conf_ok  = 0;

    foreach my $section (@sections){
        if ( ! first { $section eq $_ } keys %{$conf} ){
            print "$section section is missing.\nCheck you configuration file\n";
            exit 2;
        }}

    foreach my $section ( keys %{$conf} ) {
        foreach my $parameter ( keys %{ $conf->{$section} } ){
            if(
                $parameter =~ /[\@#\-%&\$*+()]/ ||
                $conf->{$section}{$parameter} =~ /[#\-%&\$*+()]/
            ){
                print "[$section]\n";
                print "\t$parameter = $conf->{$section}{$parameter}\n";
                $conf_ok = 1;
            }}
    }

    print "[WARN] Custom config file $conf->{advanced}{custom} not found\n"
        if( $conf->{advanced}{custom} && !-e "$conf->{advanced}{custom}" );

    if( $conf_ok != 0 ){
        print "Config [ERROR]\n";
        exit 2;
    } else {
        print "Config [OK]\n"
            and exit 0 if $chconfig;
    }

    return 0;
}

####################
# Special params   #
####################
# check config
check_config();

# display help
usage() if $showhelp;

# show version
if( $showV ){
    print "$welcome\n\n";
    exit 0;
}

# Global config
my $logfacility = $conf->{global}{facility} || 'deamon';
my $lock_dir    = $conf->{global}{lock_dir} || '/var/lock/barch';
my $pidfile     = $conf->{global}{pidfile}  || 'barch.pid';
my $work_dir    = $conf->{global}{work_dir} || '/var/cache/barch';
my $reportfile  = $conf->{global}{report}   || '/var/cache/barch/status';
my $bind_addr   = $conf->{global}{listen}   || '127.0.0.1';
my $bind_port   = $conf->{global}{port}     || '3088';
my $mount_dir   = "$work_dir/mounts";

# Defaults
my $check_drbd  = $conf->{default}{check_drbd}  || 'false';
my $backup_lvm  = $conf->{default}{backup_lvm}  || 'false';
my $skip_always = $conf->{default}{skip_always} || 'swap';
my $instance    = $conf->{default}{instance}    || `hostname`;
my $vol_grace   = $conf->{default}{vol_grace}   || 600;
my $vol_cycle   = $conf->{default}{vol_cycle}   || '12H' ;

# DRBD
my $drbd_state  = $conf->{drbd}{drbd_state}     || 'any';
my $drbd_conn   = $conf->{drbd}{drbd_conn}      || 'Connected';
my $drbd_status = $conf->{drbd}{drbd_status}    || 'UpToDate';

# DRBD Cluster
my $member_ip   = $conf->{cluster}{member};
my $member_port = $conf->{cluster}{port};
my $member_err  = $conf->{cluster}{on_error}    || 'abort';

# Snapshots
my $snap_size   = $conf->{snapshots}{snap_size} || '10G';
my $max_snap    = $conf->{snapshots}{max_snap}  || 90;
my %mount_opt   = ( 'default' => '-o acl -o noatime -r',
                    'xfs'     => '-o noatime -o ro'    ,
                    'ntfs'    => '-o noatime -o ro'   );

# Nice and IONice configs
my $customconf  = $conf->{advanced}{custom};
my $cpu_nice    = $conf->{advanced}{cpu_nice}   || 19 ;
my $io_nice     = $conf->{advanced}{io_nice}    || 7  ;
my $max_forks   = $conf->{advanced}{max_forks}  || 1  ;
my $timer_lvs   = $conf->{advanced}{timer_lvs}  || 15 ;
my $timer_drbd  = $conf->{advanced}{timer_drbd} || 600;
my $stop_file   = $conf->{advanced}{stop_file}  || "$work_dir/.graceful";

# Duplicity
my $full_backup = $conf->{duplicity}{full}              || '1W';
my $retries     = $conf->{duplicity}{retries}           || '6' ;
my $keep_last   = $conf->{duplicity}{remove_older_than} || '2W';
my $encrypt_key = $conf->{duplicity}{encrypt_key};
my $encrypt_pass= $conf->{duplicity}{encrypt_pass};
my $rem_snapdir = $conf->{duplicity}{remote_snap_dir};
my $volsize     = $conf->{duplicity}{volsize}           || '25';
my $srcmismatch = $conf->{duplicity}{source_mismatch}   || ''  ;
my $trans_wait  = $conf->{duplicity}{maxtransfertime}   || '2H';

# target server SSH credentials
my $ssh_user    = $conf->{ssh}{user} || 'root';
my $ssh_pass    = $conf->{ssh}{password};
my $ssh_path    = $conf->{ssh}{path} || '/usr/local/backup';
my $ssh_server  = $conf->{ssh}{server};

# DRBD Params
my @drbd_view   = ();
my $drbd_dump   = ();

chomp( my $localhost = `hostname` );

####################
# Variables        #
####################
# DEBUG parameters
my $silent      = ' 1>/dev/null 2>/dev/null';
   $silent      = '' if $debug;

# Global variables
my $cv             = AE::cv;
my $report         = Config::Tiny->read( $reportfile ) || '';
my $custom         = Config::Tiny->read( $customconf ) || '';
my $duplcache      = '/root/.cache/duplicity/';
my $cycle_regex    = '^(\d+)(M|H|D|W)$';
my $fs_support     = 'ext(2|3|4)|swap|luks|lvm2';
my $mountablefs    = 'ext(2|3|4)';
my $cluster_status = 0;
my %backups        = ();
my %lvs_queue      = ();
my @lvs_array      = ();
my %queue          = ();
my @q_order        = ();
my %fullreport     = ();

####################
# Logging          #
####################
# Initialize logging
sub logger {
    my( $msg, $ident, $priority ) = @_;

    # defaults
    $priority = $priority || "info";
    $ident = $ident || 'Main';
    $ident = "Barch-$ident";

    return if !$msg;
    return if( $priority eq 'debug' && !$debug );

    $msg = "[$ident] [" . uc($priority) . "] $msg";

    # start log
    openlog $ident, "pid,cons", $logfacility;

    # write to log
    syslog( $priority, $msg );
    print "$msg\n" if $verbose;

    closelog();
}

sub exit_fatal {
    my( $msg, $ident ) = @_;
    $ident = 'Main' if !$ident;

    # write log
    logger("FATAL: $msg",$ident,'crit') if $msg;

    # cleanup
    cleanup() and exit 2;
}

sub parse_period {
    my $string = shift;

    # validate period syntax
    $string =~ /$cycle_regex/i;
    return 'invalid' if( !$1 or !$2 );

    switch( uc($2) ){
        case 'M' { return int( $1 * 60     ) }
        case 'H' { return int( $1 * 3600   ) }
        case 'D' { return int( $1 * 86400  ) }
        case 'W' { return int( $1 * 604800 ) }
    }
    return 'invalid';
}

####################
# Verification     #
####################
# verify required files/dirs exist
mkdir $lock_dir  if not -e $lock_dir;
mkdir $mount_dir if not -e $mount_dir;
`touch $reportfile`;

# Create lock file
my $lockfile = File::Lockfile->new(
    $pidfile, $lock_dir
);

if( my $pid = $lockfile->check ){
    die "Barch is already running with PID: $pid\n";
}

# run cleanup
if( $cleanup ){
    $verbose = '1';
    cleanup() and exit;
}

if( $graceful ){
    `touch $stop_file $silent`;
    logger('Daemon shutdown scheduled immediately after ' . 
           'currently running backups completion');
    exit;
}
   
# single volume to backup
if( $singleLV ){
    $verbose = '1';
    exit_fatal('Invalid volume name')
        if( $singleLV !~ m/^(\w+|[aA-zZ0-9\-\_\.\+]*)$/ );
}

# display warning
# if not binding on localhost
logger("Binding on $bind_addr:$bind_port",'Main','warning')
    if( $bind_addr ne '127.0.0.1' );

# validate cycle time
$vol_cycle  = parse_period($vol_cycle);
$vol_grace  = parse_period($vol_grace);
$trans_wait = parse_period($trans_wait);

logger("[ERR] Invalid volume backup cycle (vol_cycle)",'Main','err') and exit 2
    if $vol_cycle eq 'invalid';

logger("[ERR] Invalid volume grace period (vol_grace)",'Main','err') and exit 2
    if $vol_grace eq 'invalid';

logger("[ERR] Invalid chunk transfer time (maxtransfertime)",'Main','err') and exit 2
    if $trans_wait eq 'invalid';

####################
# daemonize        #
####################
&daemonize($pwd) if $daemon;

####################
# Cleanup          #
####################
# remove old lockfiles
opendir my $dir, "$lock_dir";
my @lock_files = readdir $dir;
closedir $dir;

foreach my $file ( @lock_files ){
    next if $file =~ /^\./;

    unlink "$lock_dir/$file";
}
$lockfile->write;

# remove old mount points
# if left after crash
`rm -fr $mount_dir/*`
    if $mount_dir ne '/';

####################
# Subroutines      #
####################
sub parse_lvs {
    shift =~ /^\s+(\w+|[aA-zZ0-9\-\_\.\+]*)\s+(\w+)\s+[^ ]+\s+([0-9\.]+)(\w)\s+((\w+|[aA-zZ0-9\-\_\.\+]*)\s+([0-9\.]+))?/;

    return {
        uid      => md5_hex("$2.$1"),
        lvname   => $1,
        vgname   => $2,
        size     => $3,
        unit     => lc($4),
        snapsize => $7,
        origin   => $6,
        blkdev   => "/dev/$2/$1",
        lvsnap   => "${1}$pref"
    };
}

sub convert_time {
    my $time  = shift;
    return "error" if ! $time;

    my $days  = int($time / 86400);
       $time -= ($days * 86400);
    my $hours = int($time / 3600);
       $time -= ($hours * 3600);
    my $minutes = int($time / 60);
    my $seconds = $time % 60;

    $days    = $days    < 1 ? '' : $days  . 'd ';
    $hours   = $hours   < 1 ? '' : $hours . 'h ';
    $minutes = $minutes < 1 ? '' : $minutes.'m ';

    return "$days$hours$minutes${seconds}s";
}

sub is_disabled_volume {
    my ($vgname, $lvname) = @_;
    my $section = "${vgname}.${lvname}";

    return 0 if not $custom;
    return 0 if not $custom->{$section}{backup};

    if( $custom->{$section}{backup} eq 'false' ){
        # remove from status
        # file as well
        delete $report->{$section}
            if $report->{$section};

        return 1;
    }
    return 0;
}

sub check_cluster_status {
    http_get "http://$member_ip:$member_port/status", sub {
        my( $body, $hdr ) = @_;

        if( $hdr->{Status} =~ /^2/ ){
            logger("Successfuly connected to cluster member $member_ip:$member_port")
                if $cluster_status != 1;
            $cluster_status = 1;

            # synchronize status
            my $status = decode_json $body;

            foreach my $section ( keys %{ $status } ){
                my %remote = %{ $status->{$section} };
                my %local  = %{ $report->{$section} }
                    if $report->{$section};

                # nothing to sync
                next if ! %remote;

                # compare states
                if( ! %local ){
                    $report->{$section} = \%remote;
                } else {
                    $report->{$section} = \%remote
                        if $local{'timestamp'} < $remote{'timestamp'};
                }
            }
        } else {
            logger("Waiting for cluster member $member_ip:$member_port");
            $cluster_status = 0;
        }
    };
}

sub check_drbd_state {
    my ($vgname, $lvname) = @_;
    my $disk      = "/dev/$vgname/$lvname";
    my $drbd_dev  = '';
    my $drbd_disk = '';

    logger("DRBD configuration missing. Cannot identify DRBD device",$lvname,'err')
        if ! $drbd_dump->{'resource'};

    foreach my $resurce ( keys $drbd_dump->{'resource'} ){
        my $k = $drbd_dump->{'resource'}{$resurce}{'host'}{$localhost}{'volume'};
        my $d = $k->{'disk'};

        next if not $d;
        
        if( $d eq $disk ){
            $drbd_disk = $d;
            $drbd_dev  = $k->{'device'}{'content'};
            last;
        }
    }
    
    if( $drbd_disk ne '' ){
        my $drbd_name = ( split /\//, $drbd_disk )[-1];

        foreach my $dev ( @drbd_view ){
        $dev =~ /^\s+\d+\:(\w+|[aA-zZ0-9\-\_\.\+]*)\/\d+\s+(\w+)\s+(\w+)\/\w+\s+(\w+)\/.*/;

        last if ! $1;

        if( $1 eq $drbd_name && $2 && $3 && 4 ){
            return {
                dev    => $drbd_dev,
                disk   => $drbd_disk,
                state  => $3,
                conn   => $2,
                status => $4,
            };
        }}
    }
    return {dev => 'undefined'};
}

sub volume_grace_period {
    my $device = shift;
    return if not $device;

    chomp( my $datetime = `lvdisplay $device | grep -i 'creation'` );

    return if not $datetime;
    $datetime =~ /(\d+-\d+-\d+\s+\d+:\d+:\d+)/;
    return if not $1;

    my $t1 = Time::Piece->strptime($1 => '%Y-%m-%d %H:%M:%S');
    my $t2 = gmtime;
    my $diff = $t2 - $t1;

    # grace period
    return $diff < $vol_grace;
}

sub create_snapshot {
    my ($device,$lvname) = @_;
    return if not $lvname || not $device;

    # create snapshot
    `$lvm lvcreate -L${snap_size} -n ${lvname}${pref} -s $device`;

    sleep 1;
    return $?;
}

sub remove_snapshot {
    my $device = shift;
    return if not $device;

    # remove snapshot
    `$lvm lvremove -f $device`;

    sleep 1;
    return $?;
}

sub queue_backup {
    my %hash    = @_;
    my $section = "$hash{'vgname'}.$hash{'lvname'}";

    # check last backup time
    $hash{'timestamp'} = $report->{$section}{'timestamp'};

    if( $hash{'timestamp'} ){
        my @timenow = [gettimeofday];
        my $passed  = $timenow[0][0] - $hash{'timestamp'};

        return if $passed < $vol_cycle;

        # detect that volume backup
        # is late for next scheduled cycle
        if( $queue{ $hash{'uid'} } && ! $backups{ $hash{'uid'} } ){
            if( not $queue{ $hash{'uid'} }{'acknowledged'} ){
                logger("$hash{'lvname'} is in queue since previous cycle",$hash{'lvname'},'alert');

                $queue{ $hash{'uid'} }{'acknowledged'} = 1;
                $queue{ $hash{'uid'} }{'late'} = $passed;
            }
            return;
        }
    }

    # already in queue
    return if $queue{ $hash{'uid'} };

    # add volume to queue
    $queue{ $hash{'uid'} } = \%hash;

    push @q_order, $hash{'uid'};
}

sub unqueue_by_id {
    my $vol_id = shift;
    my $index  = 0;

    delete $queue{ $vol_id };

    for my $qid (@q_order){
        splice @q_order, $index, 1
            if $qid eq $vol_id;
        $index++;
    }
}

sub is_custom {
    my ($vgname, $lvname) = @_;
    my $section = "${vgname}.${lvname}";

    if( $conf->{advanced}{custom} && -e $conf->{advanced}{custom} ){
        my $custom = Config::Tiny->read($conf->{advanced}{custom});

        foreach my $key ( keys %{ $custom } ){
            return 1 if $key eq $section;
        }}
    return 0;
}

sub fs_type {
    my %hash = @_;
    my $dev  = $hash{'blkdev'};

    # custom specifications
    logger("$hash{'lvname'} has custom definitions", $hash{'lvname'})
        and return 'custom'
        if is_custom($hash{'vgname'}, $hash{'lvname'});

    # discover partitions
    return 'partition'
        if `$parted $dev print` =~ /(primary|extended)/;

    # check filesystem type
    if( lc(`$file -sL $dev`) =~ /($fs_support)/ ){
        return $1;
    }

    logger("Failed to recognize file system on $dev", $hash{'lvname'},'err');
    return 'unknown';
}

sub fs_mount_flag {
    my $fs = shift;
    return $mount_opt{$fs} if $mount_opt{$fs};
    return $mount_opt{'default'};
}

sub clear_duplicity_locks {
    my @locks = File::Find::Rule->file()
        ->name( '*.lock' )
        ->in( $duplcache );

    foreach my $files ( @locks ){
        unlink $files;
    }
}

sub cleanup {
    print 'Fatal error. work_dir is undefined' and exit 2
        if !$work_dir || !$mount_dir;

    # umount all
    `$umount -r $mount_dir/* $silent`
        if $mount_dir ne '/';

    # remove snapshots
    chomp( my @snaps = `$lvs | grep $pref` );

    logger("No snapshots to remove") and exit 0
        if not @snaps;

    foreach my $snap ( @snaps ){
        my %hash = %{ parse_lvs( $snap ) };

        # handle snapshots only
        next if( ! $hash{'snapsize'} && ! $hash{'origin'} );

        # remove partitions, if any
        `$kpartx -s -d /dev/$hash{'vgname'}/$hash{'lvname'}`;

        # umount
        `$umount $mount_dir/$hash{'lvname'} $silent`
            if $mount_dir ne '/';

        if( remove_snapshot("/dev/$hash{'vgname'}/$hash{'lvname'}") eq 0 ){
            logger("$hash{'lvname'} - snapshot removed");
        } else {
            logger("$hash{'lvname'} - failed to remove snapshot",'Main','err');
        }
    }

    exit 0;
}

sub reverse_cleanup {
    my %hash = @_;
    sleep 3;

    foreach my $action ( @{ $hash{cleanup} } ){
        if( system($action) ne 0 ){
            sleep 1;

            # action failed
            # retry in a second
            logger("Cleanup action failed: $action", $hash{'lvname'},'err')
                if system($action) ne 0;
        } else {
            logger("Cleanup: $action", $hash{'lvname'},'debug');
        }
        sleep 1;
    }
}

sub create_remote_dir {
    my $dir = shift;

    # SSH connect to
    # backup server
    my $openssh = Net::OpenSSH->new(
        $ssh_server, user => $ssh_user,
        master_opts => [ -o => "StrictHostKeyChecking=no" ]
    );

    logger("Couldn't establish SSH connection to backup server $openssh->error",'Main','err')
        and return 0
        if $openssh->error;

    $openssh->system("mkdir -p $ssh_path/$instance/$dir")
        or logger("Failed to create remote directory on $ssh_server over SSH",'Main','err')
        and return 0;

    return 1;
}

sub report {
    my %hash      = @_;
    my $section   = "$hash{'vgname'}.$hash{'lvname'}";
    my $date      = localtime;
    my @timestamp = [gettimeofday];

    return if $dry_run;

    # update existing
    if( $report->{$section} ){
        $report->{$section}{date}      = $date->cdate;
        $report->{$section}{timestamp} = "$timestamp[0][0]";
        $report->{$section}{elapsed}   = $hash{'elapsed'};
        $report->{$section}{exit_code} = $hash{'code'};
        $report->{$section}{status}    = $hash{'status'};
        $report->{$section}{hostname}  = $localhost;
        $report->{$section}{fstype}    = $hash{'fstype'};
    }
    # create new section
    else{
        $report->{$section} = {
            date      => $date->cdate,
            timestamp => "$timestamp[0][0]",
            elapsed   => $hash{'elapsed'},
            status    => $hash{'status'},
            exit_code => $hash{'code'},
            fstype    => $hash{'fstype'},
            hostname  => $localhost,
        };
    }
}

sub discover {
    my %hash    = @_;
    my $path    = $hash{'path'};
    my $section = "$hash{'vgname'}.$hash{'lvname'}";

    # verify block device exist
    if( not -e $hash{'blkdev'} ){
        $hash{'status'} = "Block device $hash{'blkdev'} doesn't exist. Skip.";
        $hash{'code'} = 2;

        logger($hash{'status'}, $hash{'lvname'},'warning');
        return %hash;
    }

    # discover structure
    $hash{'fstype'} = fs_type(%hash);

    # handle exceptions
    switch( $hash{'fstype'} ){
        case 'unknown' {
            $hash{'status'} = "Failed to recognize file system on $hash{'blkdev'}";
            $hash{'code'} = 2;
        }
        case /$skip_always/ {
            $hash{'status'} = "$hash{'blkdev'} contains $hash{'fstype'}. Skip";
            $hash{'code'} = 4;
        }
        case 'lvm2' {
            if( $backup_lvm ne 'true' ){
                $hash{'status'} = "$hash{'blkdev'} contains LVM. backup_lvm flag is not 'true'";
                $hash{'code'} = 4;
        }}
        case 'swap' {
            $hash{'status'} = "$hash{'blkdev'} contains swap. Skip";
            $hash{'code'} = 4;
        }
    }

    # return on exception
    if( $hash{'code'} ){
        logger($hash{'status'}, $hash{'lvname'},'warning');
        return %hash;
    }

    # mountable file system
    if( $hash{'fstype'} =~ m/$mountablefs/ ){
        # get mount flags
        my $mount_opts = fs_mount_flag( $hash{'fstype'} );

        push(@{ $hash{hierarchy} }, $hash{'fstype'});

        # mount file system
        `$mount -t $hash{'fstype'} $mount_opts $hash{'blkdev'} $path`;

        if( $? ne 0 ){
            $hash{'status'} = "Failed to mount $hash{'blkdev'} on $path";
            $hash{'code'} = 2;

            logger($hash{'status'}, $hash{'lvname'},'err');
            return %hash;
        } else {
            logger("Mount $hash{'blkdev'} on $path (opts: $mount_opts)",$hash{'lvname'},'debug');
            push(@{ $hash{cleanup} }, "$umount $path");
        }

        $hash{'status'} = "Mount succeeded";
        $hash{'code'} = 0;

        return %hash;
    }
    # handle partition table
    elsif( $hash{'fstype'} eq 'partition' ){
        logger("$hash{'blkdev'} contains partition table",$hash{'lvname'},'debug');

        # get partitions
        chomp( my @partition = `$kpartx -l $hash{'blkdev'} | awk '{print \$1}'` );

        if( system("$kpartx -s -a $hash{'blkdev'}") ne 0 ){
            $hash{'status'} = "Failed to map partitions on $hash{'blkdev'}";
            $hash{'code'} = 2;

            logger($hash{'status'}, $hash{'lvname'},'err');
            return %hash;
        } else {
            my %data = %hash;

            foreach my $part (@partition){
                logger("Partition found: $part",$hash{'lvname'},'debug');
                push(@{ $hash{hierarchy} }, "partition");

                $data{'path'}   = "$hash{'path'}/$part";
                $data{'blkdev'} = "/dev/mapper/$part";

                # create temporary mount point
                `mkdir -p $data{'path'}`;

                # rediscover
                %data = discover(%data);

                if( $data{'code'} ne 0 && $data{'code'} ne 4 && $data{'code'} ne 6 ){
                    $hash{'status'} = "One or more partition recognition failed";
                    $hash{'code'} = 2;

                    logger($hash{'status'}, $hash{'lvname'},'err');
                    return %hash;
            }}

            # cleanup
            push(@{ $hash{cleanup} }, "$kpartx -s -d $hash{'blkdev'}");
            %hash = %data;
        }
    }
    # LVM2
    elsif( $hash{'fstype'} eq 'lvm2' ){
        push(@{ $hash{hierarchy} }, "LVM");
        logger("$hash{'blkdev'} contains LVM",$hash{'lvname'},'debug');

        # discover VG name(s)
        chomp(my @VG = `pvdisplay $hash{'blkdev'} | grep -i "vg name" | awk '{print \$NF}'`);

        my $filter = '';
        foreach my $inVG (@VG){
            push(@{ $hash{hierarchy} }, "Volume Group $inVG");

            # activate volume group
            if( system("vgchange -ay $inVG $silent") ne 0 ){
                $hash{'status'} = "vgchange failed to activate $inVG";
                $hash{'code'} = 2;

                logger($hash{'status'}, $hash{'lvname'},'err');
            }

            sleep 0.2;
            $filter .= " | grep $inVG";
        }

        if( $hash{'code'} eq 0 ){
            # filter relevant lvs
            chomp( my @innerLV = `lvs $filter` );

            my %data = %hash;

            foreach my $lv (@innerLV){
                my %innerLV = %{ parse_lvs( $lv ) };

                push(@{ $hash{hierarchy} }, "Volume: $lv");

                $data{'path'}   = "$hash{'path'}/data{'vgname'}/data{'lvname'}";
                $data{'blkdev'} = "/dev/data{'vgname'}/data{'lvname'}";

                # create temporary mount point
                `$mkdir -p $data{'path'}`;

                # rediscover
                %data = discover(%data);

                if( $data{'code'} ne 0 && $data{'code'} ne 4 && $data{'code'} ne 6 ){
                    $hash{'status'} = "One or more Logical Volumes in data{'vgname'} recognition failed";
                    $hash{'code'} = 2;

                    logger($hash{'status'}, $hash{'lvname'},'err');
                    return %hash;
        }}}

        foreach my $inVG (@VG){
            push(@{ $hash{cleanup} },"vgchange -an $inVG $silent");
        }

        return %hash;
    }
    # custom
    elsif( $hash{'fstype'} eq 'custom' ){
        if( ! $custom->{$section}{backup} ){
            logger('Custom config backup flag is missing',$hash{'lvname'},'warning');

            $hash{'status'} = 'Custom config error';
            $hash{'code'} = 1;
            return %hash;
        }

        if( $custom->{$section}{backup} eq 'true' ){
            my $cfs    = $custom->{$section}{fs_type};
            my $pre_m  = $custom->{$section}{pre_mount};
            my $post_m = $custom->{$section}{post_mount};
            my $mopt   = $custom->{$section}{mount_opt};

            # pre-mount script
            if( $pre_m ){
                `$pre_m` if $pre_m ne 'none';

                if( $? ne 0 ){
                    logger("Pre-mount script failed (exit code $?)",$hash{'lvname'},'err');
                    $hash{'status'} = 'Pre-mount script failed';
                    $hash{'code'} = 2;
                    return %hash;
            }}

            # get mount flags
            if( ! $mopt ){
                logger("No mount opts specified. Using defaults",hash{'lvname'},'debug');
                $mopt = fs_mount_flag($cfs);
            }

            # mount filesystem
            `$mount -t $cfs $mopt $hash{'blkdev'} $path`;

            if( $? ne 0 ){
                $hash{'status'} = "Failed to mount $hash{'blkdev'} on $path";
                $hash{'code'} = 2;

                logger($hash{'status'}, $hash{'lvname'},'err');
                return %hash;
            } else {
                logger("Mount $hash{'blkdev'} on $path (opts: $mopt)",$hash{'lvname'},'debug');
                push(@{ $hash{cleanup} }, "$umount $path");

                if( $post_m ){
                    push(@{ $hash{cleanup} }, "$post_m")
                        if $post_m ne 'none';
                }
            }

            $hash{'status'} = "Mount succeeded";
            $hash{'code'} = 0;

            return %hash;
        } else {
            $hash{'status'} = "$hash{'lvname'} backup is disabled by custom.conf. skip.";
            $hash{'code'} = 4;

            logger($hash{'status'},$hash{'lvname'});
            return %hash;
        }
    }
    # Unknown file system
    else {
        $hash{'status'} = "Failed to recognize file system on $hash{'blkdev'}";
        $hash{'code'} = 2;

        logger($hash{'status'}, $hash{'lvname'},'err');
        return %hash;
    }
}

sub is_locked_HTTP {
    my %hash = @_;
    my $ua   = LWP::UserAgent->new;
    my $resp = $ua->get("http://$member_ip:$member_port/backups");

    if( $resp->is_success ){
        my $body = decode_json $resp->decoded_content;

        foreach my $volume ( keys %{ $body } ){
            my %remDRBD = %{ $body->{$volume} };

            return 'locked' if(
                $remDRBD{'vgname'} eq $hash{'vgname'} &&
                $remDRBD{'lvname'} eq $hash{'lvname'}
            );
        }
    } else {
        logger("Cluster member $member_ip:$member_port is unreachable",$hash{'lvname'},'warning');
        return 'error';
    }

    return 'not locked';
}

sub latest_timestamp {
    my %hash    = @_;
    my $section = "$hash{'vgname'}.$hash{'lvname'}";
    my $ua      = LWP::UserAgent->new;
    my $resp    = $ua->get("http://$member_ip:$member_port/status");

    if( $resp->is_success ){
        my $status = decode_json $resp->decoded_content;
        return $hash{'timestamp'} if ! $status->{$section};

        if( $status->{$section} ){
            return if ! $hash{'timestamp'};
            my %remote = %{ $status->{$section} };

            if( $remote{'timestamp'} > $hash{'timestamp'} ){
                $report->{$section} = \%remote;
                return $remote{'timestamp'};
            }
        } else {
            return $hash{'timestamp'};
        }
    } else {
        return 'error';
    }
}

sub backup {
    my %hash     = @_;
    my $start    = time;
    my $path     = "$mount_dir/$hash{'lvname'}";
    my $device   = "/dev/$hash{'vgname'}/$hash{'lvname'}";
    my $section  = "$hash{'vgname'}.$hash{'lvname'}";
    my $lv_lfile = "${section}.lock";
    my $lv_lock  = File::Lockfile->new($lv_lfile, "$lock_dir");

    # add required keys
    # to already existing
    %hash = ( %hash,
        path      => $path,
        fstype    => '',
        elapsed   => 0,
        cleanup   => [],
        hierarchy => []
    );

    # skip if volume is disabled
    # in custom.conf file
    if( is_disabled_volume( $hash{'vgname'}, $hash{'lvname'} ) ){
        logger("$hash{'lvname'} backup is disabled in custom.conf");
        return;
    }

    # verify other instance
    # not running
    logger("Volume is locked by other instance", $hash{'lvname'}, 'alert') and return
        if -e "$lock_dir/$hash{'lvname'}.lock";
 
    # check last backup time
    $hash{'timestamp'} = $report->{$section}{'timestamp'};
    my $latest = latest_timestamp( %hash );

    if( $latest ){
        if( $latest ne 'error' ){
            $hash{'timestamp'} = $latest;
        } else {
            $hash{'status'} = "Failed to get status from cluster member $member_ip:$member_port";
            logger($hash{'status'},$hash{'lvname'},'warning');

            if( lc($member_err) eq 'abort' ){
                $hash{'code'} = 2;
                return %hash;
            }
        }
    }

    if( $hash{'timestamp'} ){
        my @timenow = [gettimeofday];
        my $passed  = $timenow[0][0] - $hash{'timestamp'};

        if( $passed < $vol_cycle ){
            logger("$hash{'lvname'} was backed up $passed sec ago. Skip.");
            return;
        }
    }

    # check DRBD state if exist
    # and enabled in config
    if( lc($check_drbd) eq 'true' ){
        $hash{'drbd'} = check_drbd_state($hash{'vgname'}, $hash{'lvname'});

        if( $hash{'drbd'}->{'dev'} ne 'undefined' ){
            # check DRBD state
            if( lc($drbd_state) ne 'any' &&
                lc($drbd_state) ne lc( $hash{'drbd'}->{'state'} )
            ){
                logger("DRBD device state: $hash{'drbd'}->{'state'}, skip",
                       $hash{'lvname'},'warning' );
                return;
            }

            # check DRBD connection
            if( lc($drbd_conn) ne 'any' &&
                lc($drbd_conn) ne lc( $hash{'drbd'}->{'conn'} )
            ){
                logger("DRBD device state: $hash{'drbd'}->{'conn'}, skip",
                       $hash{'lvname'}, 'warning' );
                return;
            }

            # check DRBD status
            if( lc($drbd_status) ne 'any' &&
                lc($drbd_status) ne lc( $hash{'drbd'}->{'status'} )
            ){
                logger("DRBD device state: $hash{'drbd'}->{'status'}, skip",
                       $hash{'lvname'},'warning' );
                return;
            }

            logger("DRBD detected (state: ".$hash{'drbd'}->{'state'}.", conn: ".$hash{'drbd'}->{'conn'}.", ".
                   "status: ".$hash{'drbd'}->{'status'}.")", $hash{'lvname'}, 'debug');
        } else {
            logger("No DRBD device found", $hash{'lvname'}, 'debug');
        }
    }

    ### Backup process START
    # Discover device structure
    $backups{ $hash{'uid'} } = \%hash;

    fork_call {
        # never backed up
        # apparently, a new volume
        if( not $hash{'timestamp'} ){
            if( volume_grace_period( $device ) ){
                logger("Volume was never backed up. ".
                   "Delaying for grace period", $hash{'lvname'}, 'alert');

                $hash{'code'} = 4;
                $hash{'status'} = "Delaying for grace period";

                return %hash;
        }}

        # verify volume is not
        # locked by other cluster member
        my $locked = is_locked_HTTP( %hash );

        # retry on error
        if( $locked eq 'error' ){
            sleep 1;
            $locked = is_locked_HTTP( %hash );
        }

        switch( $locked ){
            case 'locked' { 
                $hash{'code'} = 4;
                $hash{'status'} = "Volume is locked by other instance";

                logger($hash{'status'}, $hash{'lvname'}, 'warning');
                return %hash;
            }
            case 'error' {
                $hash{'status'} = "Remote cluster member is unreachable";
                $hash{'code'} = 4;

                if( lc($member_err) eq 'abort' ){
                    $hash{'code'} = 2;
                    return %hash;
            }}
        }

        # create lock file
        $lv_lock->write;

        # run pre-backup script
        if( is_custom($hash{'vgname'}, $hash{'lvname'}) ){
            my $script = $custom->{$section}{'pre_backup'} || '';

            if( $script ne 'none' ){
                logger('Running pre-backup script', $hash{'lvname'});

                # run it
                `$script`;

                if( $? ne 0 ){
                    $hash{'status'} = "Pre-backup script failed to run (exit code: $?)";
                    $hash{'code'} = 2;

                    logger($hash{'status'}, $hash{'lvname'}, 'err');
                    return %hash;
                } else {
                    logger('Pre-backup script complete successfuly',$hash{'lvname'});
                }
        }}

        # create snapshot
        if( create_snapshot( $device, $hash{'lvname'} ) ne 0 ){
            $hash{'code'} = 2;
            $hash{'status'} = "Failed to create snapshot. Aborting.";

            logger($hash{'status'},$hash{'lvname'},'err');
            return %hash;
        } else {
            logger("Snapshot $hash{'lvname'}${pref} created", $hash{'lvname'});
        }

        # change device to snapshot
        $hash{'blkdev'} = "/dev/$hash{'vgname'}/$hash{'lvsnap'}";

        # create temporary mount point
        mkdir $path;

        # recursive discover
        %hash = discover(%hash);

        # change device and path
        $hash{'blkdev'} = "/dev/$hash{'vgname'}/$hash{'lvsnap'}";
        $hash{'path'}   = "$mount_dir/$hash{'lvname'}";

        # remember to remove
        # snapshot on finish
        push(@{ $hash{cleanup} },"$lvm lvremove -f /dev/$hash{'vgname'}/$hash{'lvsnap'} $silent");

        # verify gpg key exists
        my $keys = `$gpg --list-keys | grep sub | grep $encrypt_key`;

        if( $? ne 0 ){
            $hash{'status'} = "Encryption key $encrypt_key not found";
            $hash{'code'} = 2;
        }

        # prepare backup directory
        # on backup server
        if( ! create_remote_dir( $hash{'lvname'} ) ){
            $hash{'status'} = "Failed to create remote directory on $ssh_server over SSH";
            $hash{'code'} = 2;
        }

        # cleanup on error
        if( $hash{'code'} ne 0 ){
            logger("Structure auto discover failed: $hash{'status'}", $hash{'lvname'},'err');
            reverse_cleanup( %hash );
            report( %hash );

            # remove lock file
            $lv_lock->remove;
        } elsif( $dry_run ){
            # rest a bit
            sleep 5;

            $hash{'status'} = "Skipping backup. dry-run mode";
            $hash{'code'} = 4;

            logger($hash{'status'});
            reverse_cleanup( %hash );
            report( %hash );

            # remove lock file
            $lv_lock->remove;
        }

        sleep 0.5;
        clear_duplicity_locks();
        return %hash;
    } sub {
        %hash = @_;

        # abourt volume backup if
        # 'skip' or 'err' returned
        delete $backups{ $hash{'uid'} } and return
           if !@_ or $hash{'code'} ne 0;

        logger('Starting backup...',$hash{'lvname'});
        $backups{ $hash{'uid'} } = \%hash;

        # export env
        $ENV{PASSPHRASE} = $encrypt_pass;

        # --allow-source-mismatch
        $srcmismatch = '--allow-source-mismatch'
            if $srcmismatch eq 'allow';

        # verbosity
        my $verbosity = "notice";
        $verbosity = "info" if $debug;

        # prepare duplicity
        # command arguments
        my $exc = "$duplicity --verbosity $verbosity $srcmismatch --volsize $volsize" .
                  " --num-retries $retries --encrypt-key=$encrypt_key" .
                  " --full-if-older-than $full_backup $hash{'path'} $rem_snapdir/$instance/$hash{'lvname'}";
        my $cmd = "$nice -n $cpu_nice $ionice -c2 -n${io_nice} $exc";

        # run duplicity
        logger("duplicity: $cmd",$hash{'lvname'},'debug');

        my @stdout  = "";
        my $backup = run_cmd "$cmd",
           '1>' => sub { push(@stdout, $_[0]) if $_[0]; },
           '2>' => sub { return if ! @_;
                         logger("duplicity error trace: @_",$hash{'lvname'},'err');
                         `kill $backups{ $hash{'uid'} }{'pid'}`
                            if $backups{ $hash{'uid'} }{'pid'}; },
           '$$' => \$backups{ $hash{'uid'} }{'pid'};

        # backup process finished
        # check results
        $backup->cb( sub {
            if( shift->recv ){
                $hash{'status'} = "Duplicity backup failed";
                $hash{'code'} = 2;

                logger($hash{'status'}, $hash{'lvname'},'err');
            } else {
                $hash{'status'} = "Success";
                $hash{'code'} = 0;

                logger("Duplicity backup succeeded", $hash{'lvname'});
            }

            # cleanup
            fork_call {
                # reverse cleanup
                reverse_cleanup( %hash );

                # clean cache files
                my $exc = `$duplicity cleanup --force --extra-clean $rem_snapdir/$instance/$hash{'lvname'}`;

                if( $? ne 0 ){
                    logger("Cache cleanup failed", $hash{'lvname'},'warning');
                    logger("duplicity: $exc",$hash{'lvname'},'debug');
                } else {
                    logger("Cache cleaned up", $hash{'lvname'},'debug');
                }

                # rotate backups
                $exc = `$duplicity remove-older-than $keep_last --force $rem_snapdir/$instance/$hash{'lvname'}`;

                if( $? ne 0 ){
                    logger('Older backups deletion process failed',$hash{'lvname'},'err');
                    logger("duplicity: $exc",$hash{'lvname'},'debug');
                } else {
                    logger("Deleting backups older than $keep_last",$hash{'lvname'});
                }

                # wait to be sure that
                # volume is not used
                sleep 0.5;

                # remove temporary mount point
                `rm -fr $hash{'path'}`
                    if $hash{'path'} ne '/';

                return 'finish';
            } sub {
                # remove instance
                delete $backups{ $hash{'uid'} };

                # delete from queue
                unqueue_by_id( $hash{'uid'} );

                # remove lockfile
                `rm -f ${lock_dir}/${lv_lfile}`
                    if "${lock_dir}/${lv_lfile}" ne '/';
            };

            # report on finish
            $hash{'elapsed'} = (time - $start);
            report(%hash);
        });
    };
}

####################
# Pre-backup       #
####################
# start
logger("Starting pre-backup procedures");

# create DRBD watcher
# every 10min
my $wdr = AE::timer $timer_drbd, $timer_drbd, sub {
    return if $check_drbd ne 'true';

    fork_call {
        my @return = ();

        chomp(@drbd_view = `drbd-overview`);
        chomp($drbd_dump = `drbdadm dump-xml`);

        $return[0] = \@drbd_view;
        $return[1] = \$drbd_dump;
        return @return;
    } sub {
        return if !$_[0];
        return if !$_[1];

        my $xml    = XML::Simple->new();
        $drbd_dump = $xml->XMLin($_[1]);
        @drbd_view = @{ $_[0] };
    };
};

if( $check_drbd eq 'true' ){
    chomp(@drbd_view = `drbd-overview`);
    chomp($drbd_dump = `drbdadm dump-xml`);

    my $xml    = XML::Simple->new();
    $drbd_dump = $xml->XMLin($drbd_dump);
} else {
    # remove DRBD watcher
    # if not required
    undef $wdr;
}

# remove duplicity lock files
# if left after failure
clear_duplicity_locks();

####################
# Start backup     #
####################
logger("Barch $version started");

# create logical volumes watcher
# every 30sec
my $wlv = AE::timer 0, $timer_lvs, sub {
    # verify cluster is online
    check_cluster_status();

    # wait for cluster
    return if $cluster_status != 1;

    # handle graceful stop option
    logger("STOPPING. Wating for running backup(s) to finish")
        and return if -e $stop_file;

    fork_call {
        chomp( my @cmd = `$lvs` );
        return @cmd;
    } sub {
        return if not @_;
        my @volumes = @_;

        # flush lvm queue
        %lvs_queue = ();
        @lvs_array = ();

        # remove first line
        splice @volumes, 0, 1;

        my $length = scalar @volumes;
        my $i = 0;

        for(; $i < $length; $i++ ){
            my %hash = %{
                parse_lvs( $volumes[$i] )
            };

            # if --only option specified
            if( $singleLV ){
                next if ( $hash{'lvname'} ne $singleLV );
            }

            # handle snapshots
            if( $hash{'snapsize'} ){
                # monitor created snapshots
                # verify snapshot is not full
                my $regex = "/(.*)$pref/";
                if( $volumes[$i] =~ $regex && $hash{'snapsize'} >= $max_snap ){
                    # find origin volume
                    next if not $1;

                    my $origin = md5_hex("$hash{'vgname'}.$1");
                    my $origlv = $backups{$origin}{'lvname'};
                    my $PID    = $backups{$origin}{'pid'};

                    next if not $PID;

                    # abort backup
                    logger("$hash{'lvname'} snapshot is running out of space. ".
                           "Aborting backup", $origlv,'warning');
                    
                    # kill duplicity process
                    `kill $PID`;

                    logger("Backup terminated (PID: $PID)", $origlv,'err');
                }
            # handle volumes
            } else {
                $lvs_queue{ $hash{'uid'} } = \%hash;

                my @section = ( $hash{'vgname'}, $hash{'lvname'} );
                push @lvs_array, \@section;

                # skip if volume is disabled
                # in custom.conf file
                next if is_disabled_volume( $hash{'vgname'}, $hash{'lvname'} );

                # schedule backup
                queue_backup( %hash );
            }
        }

        # warn if no volumes
        # to backup
        logger('No logical volumes found','Main','warning')
            if not %lvs_queue;

        # unexpected error
        return if ! %lvs_queue;
        return if ! %queue;

        # stale volumes that
        # no longer exists
        for my $vol_id (@q_order){
            next if $lvs_queue{ $vol_id };

            my $lvname  = $queue{ $vol_id }{'lvname'};
            my $vgname  = $queue{ $vol_id }{'vgname'};
            my $section = "$vgname.$lvname";

            logger("$lvname volume no longer exist. Removing from queue",$lvname,'debug');
            unqueue_by_id($vol_id);

            # remove from status file
            delete $report->{$section}
                if $report->{$section};
        }

        foreach my $s ( keys %{ $report } ){
            my $uid = md5_hex($s);

            if( ! $lvs_queue{$uid} ){
                delete $report->{$s}
                    if $report->{$s};
        }}
    }
};

# create backup queue watcher
# every 5sec
my $wqueue = AE::timer 5, 1, sub {
    my $tasks   = scalar keys %queue;
    my $running = scalar keys %backups;

    # manage backups timeout
    # verify files written to backup server
    if( not $dry_run ){
        foreach my $volume ( keys %backups ){
            # increase elapsed time
            $backups{$volume}{'elapsed'} += 1;

            # get volume info
            my %hash = %{ $backups{$volume} };
            next if $hash{'elapsed'} < 2;

            if( $backups{$volume}{'watcher'} ){
                $backups{$volume}{'watcher'} += 1;
            } else {
                $backups{$volume}{'watcher'} = 1;
            }

            # maxtransfertime
            next if $backups{$volume}{'watcher'} < $trans_wait;

            my $cmd = "$ssh -l $ssh_user $ssh_server 'du -hs $ssh_path/$instance/$hash{'lvname'}'";
            my $watcher = run_cmd $cmd,
               '1>' => sub {
                    return if ! @_;

                    chomp( my $result = $_[0] );
                    $result =~ /^(\d+)(\w)\t+.*/;

                    return if ! $1 || !$2;

                    if( $backups{$volume}{'remsize'} ){
                        logger("No data transfered to backup server during the last ".
                               convert_time($trans_wait), $hash{'lvname'}, 'warning' )
                        if $backups{$volume}{'remsize'} eq "$1$2";
                    } else {
                        $backups{$volume}{'remsize'} = "$1$2";
                }};
            $backups{$volume}{'watcher'} = 1;
    }}

    # graceful stop
    # do NOT start new backups
    if( -e $stop_file ){
        # truncate queue
        @q_order = ();
        %queue   = ();

        if( $running < 1 ){
            # remove stop file
            `rm -f $stop_file`;
            sigHandler('INT') ;
            return;
        }
    }

    return if $tasks   < 1;
    return if @q_order < 1;
    return if $running >= $max_forks;

    # run scheduled task
    my $vol_id  = shift @q_order;
    my %volume  = %{ $queue{$vol_id} };

    # backup volume
    backup( %volume );
};

# create custom.conf watcher
# every 1min
my $wconf = AE::timer 60, 60, sub {
    $custom = Config::Tiny->read( $customconf ) || ''
        if not $dry_run;
};

# write report file
# every 10sec
my $wreport = AE::timer 5, 10, sub {
    $report->write($reportfile)
        or logger("Failed to write report file",'Main','err')
        if not $dry_run;
};

sub sigHandler {
    print STDERR "\nAborting backups!\nPlease wait...\n";

    foreach my $volume ( keys %backups ){
        my %hash = %{ $backups{$volume} };

        $hash{'status'} = "Backup terminated";
        $hash{'code'} = 2;

        report( %hash );
        
        # kill duplicity processes
        `kill $hash{'pid'}` if $hash{'pid'};

        # cleanup
        reverse_cleanup( %hash );
        logger("Backup terminated (SIG: @_)", $hash{'lvname'},'err');
    }

    # remove stop file
    `rm -f $stop_file`
        if -e $stop_file;

    # remove lockfile
    `rm -f ${lock_dir}/${pidfile}`
        if "${lock_dir}/${pidfile}" ne '/';

    # duble check
    cleanup();

    # verify all snapshots removed
    chomp( my @snaps = `$lvs | grep $pref` );

    logger("Barch failed to remove one or more snapshot(s)",'Main','crit')
        if @snaps;

    # write report file
    $report->write($reportfile)
        or logger("Failed to write report file",'Main','err')
        if not $dry_run;

    sleep 0.8;
    $cv->send;
}

sub daemonize {
    my $pwd = shift;

    chdir $pwd or die "Can't chdir to $pwd: $!";
    open STDIN, '/dev/null'    or die "Can't read from /dev/null: $!";
    open STDOUT, '>>/dev/null' or die "Can't write to /dev/null: $!" ;
    open STDERR, '>>/dev/null' or die "Can't write to /dev/null: $!" ;
    defined( my $pid = fork )  or die "Can't fork: $!";

    exit if $pid;
    setsid or die "Can't start a new session: $!";
    umask 0;
}

# Start HTTP server
my $httpd = Twiggy::Server->new(
    host => $bind_addr,
    port => $bind_port,
);

$httpd->register_service( sub {
    my $env  = shift;
    my $path = $env->{'PATH_INFO'} || '/';
    my $time = time;

    if( $path eq '/queue' ){
        my $forks   = scalar keys %backups;
        my $index   = 0 ;
        my @running = ();
        my @jobs    = ();
        my $is_late = '';

        # generate response
        my $page = "| LV" . " "x25 .
                   "| Since Last backup" . " "x2 .
                   "| Queue" . " "x25 .
                   "| Running ($forks/$max_forks forks):\n".
                   "="x117 . "\n";

        foreach my $q ( keys %backups ){
            my $remsize = $backups{$q}{'remsize'} || '';
            my $drbddev = '';

            if( $backups{$q}{'drbd'}->{'dev'} ne 'undefined' ){
                $drbddev = '[DRBD] ';
            }
            push @running, "${drbddev}$backups{$q}{'lvname'} $remsize";
        }

        foreach my $j ( @q_order ){
            $is_late = '[!]' if $queue{$j}{'late'};
            push @jobs, "$queue{$j}{'lvname'} $is_late";
        }

        foreach my $lv ( @lvs_array ){
            my $date     = '';
            my $runqueue = '|' . ' 'x30;
            my $queuejob = '|' . ' 'x30;
            my @section  = @{ $lv };

            $runqueue = " $running[$index]"
                if defined $running[$index];

            $queuejob = sprintf("|%2.0f %-26s", ($index+1), $jobs[$index])
                if defined $jobs[$index];

            if( $report->{"$section[0].$section[1]"}{timestamp} ){
                $date = $report->{"$section[0].$section[1]"}{timestamp};
                $date = convert_time( $time - $date );
            }

            $date  = $date || '-';
            $page .= sprintf(" %-26s | %-18s $queuejob $runqueue\n",
                $section[1], $date );
            $index++;
        }

        return [
            200,
            [ 'Content-type' => 'text/plain' ],
            [ $page ],
        ];
    } elsif( $path eq '/backups' ){
        my $json = encode_json \%backups;
        return [
            200,
            [ 'Content-type' => 'text/plain' ],
            [ $json ],
        ];
    } elsif( $path eq '/status' ){
        my %status = %{ $report };
        my $json   = encode_json \%status;
        return [
            200,
            [ 'Content-type' => 'text/plain' ],
            [ $json ],
        ];
    } elsif( $path eq '/queue' ){
        my $json = encode_json \%queue;
        return [
            200,
            [ 'Content-type' => 'text/plain' ],
            [ $json ],
        ];
    } else {
        return [
            403,
            [ 'Content-Type' => 'text/plain' ],
            [ "" ],
        ];
    }
});

$cv->recv;
$lockfile->remove;
exit 0;

# vim:sw=4:ts=4:et